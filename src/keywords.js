export const keywordMap = {
  dijkstra:  [
    "shortest path", "dijkstra", "single source", "sssp", "route", "minimum cost", "graph travel",
    "one to all", "source to destination", "network path", "least cost path", "pathfinding", "routing", "find path",
    "map direction", "travel cost", "minimum path", "shortest distance", "navigate", "source node", "destination node",
    "directed graph", "undirected graph", "vertex distance", "weight", "dijkstra's algo", "queue", "greedy path", 
    "start node", "end node", "shortest edge", "city map", "navigation", "gps routing", "priority queue",
    "graph weight", "edge cost", "single point source", "quickest path", "point to point", "dijkstra method",
    "minimum route", "search graph", "weighted graph", "edge list", "path optimization", "cheapest path", "distance minimization",
    "optimal route", "graph path", "path cost", "node path", "minimum travel", "travel graph", "path map", "fastest route",
    "network optimization", "source travel", "target node", "shortest connection", "path matrix", "graph traverse", "low cost",
    "minimizing path", "distance vector", "shortest solution", "dijkstra solution", "start to end", "greedy queue", "vertex map",
    "direction cost", "direction map", "next node", "prev node", "explore node", "graph algo", "step path", "node jump",
    "dijkstra calc", "path logic", "navigation logic", "short route", "least edge", "priority map", "short node", "dijkstra core",
    "edge search", "map build", "path find", "short weight", "graph nodes", "graph length", "weighted edges", "edge scan",
    "edge queue", "shortest nav", "minimize hops", "hops cost", "hops route", "least graph", "hop count", "shortest vertex",
    "minimum stops", "route finder", "edge finder", "vertex hop", "graph index", "dijkstra theory", "dijkstra method",
    "minimizing route", "shortest steps", "fast path", "route builder", "dijkstra example", "navigation engine",
    "shortest solver", "best route", "quickest route", "route logic", "dijkstra core", "shortest calc", "graph builder",
    "path search", "optimal graph", "least graph path", "source destination", "weighted map", "route network",
    "dijkstra tree", "shortest algo", "path discovery", "dijkstra discover", "nav system", "min travel", "fast travel",
    "graph-based", "node travel", "least cost", "travel engine", "path explorer", "node weight", "node hops", "short calc",
    "node cost", "optimal travel", "optimized graph", "fast pathing", "vertex jump", "shortest way", "path router",
    "quickest graph", "route engine", "graph route", "distance route", "weighted queue", "map matrix", "cost matrix",
    "vertex selection", "graph minimize", "node graph", "node distance", "weight logic", "traverse map", "route planner",
    "least node", "shortest network", "weighted nav", "node planner", "graph theory", "graph solve", "short weight find",
    "dijkstra design", "route search", "dijkstra idea", "gps finder", "gps calc", "best nav", "quickest finder",
    "dijkstra solver", "graph route map", "best graph path", "lowest weight", "edge selection", "dijkstra queue",
    "start to goal", "goal path", "graph jump", "jump cost", "travel node", "vertex point", "path cost calc",
    "optimal point", "least connection", "least cost edge", "vertex to vertex", "fast edge", "best route finder",
    "cheapest nav", "graph routing", "node track", "vertex path", "edge distance", "path walk", "minimum move",
    "shortest journey", "path chart", "map cost", "dijkstra board", "graph diagram", "step cost", "hop path",
    "graph weight find", "low travel", "quick path", "cheap route", "short nav", "optimized nav", "nav finder",
    "quickest calc", "step shortest", "minimize travel", "graph search", "destination finder", "path pointer",
    "path location", "min edge path", "shortest connect", "route map", "cost finder", "least map", "weight minimizer",
    "vertex router", "route manager", "graph minimize path", "navigation planner", "dijkstra grid", "minimum node path",
    "least nav", "cost efficiency", "graph move", "minimize movement", "short graph", "short jump", "edge connector",
    "path manager", "travel estimator", "path estimator", "fastest jump", "least distance", "low cost routing",
    "minimum calculation", "fast jump", "efficient route", "travel mapper", "minimizer", "weight search", "path hop",
    "jump planner", "short weight route", "jump finder", "shortest queue", "optimized queue", "dijkstra priority",
    "shortest find", "dijkstra logic", "routing engine", "optimal hops", "gps shortest", "shortest priority",
    "quick routing", "low hop", "shortest processor", "graph jump", "route selector", "shortest route map",
    "node finder", "path detector", "graph navigator", "shortest router", "travel selector", "step shortest path",
    "queue graph", "cost travel", "greedy route", "greedy weight", "greedy shortest", "graph minimize",
    "graph hops", "node selector", "travel graph", "hop select", "graph nav", "path resolver", "cheapest connection",
    "shortest detector", "weight map", "travel node path", "dijkstra weight", "quickest point", "path end",
    "least cost graph", "minimum nav"
  ],
  jobsequencing: [
    "job sequence", "job sequencing", "maximum profit", "deadline", "jobs", "profit", "greedy job", "schedule jobs",
    "greedy scheduling", "job priority", "job deadline", "task order", "task profit", "sequence max", "job slot",
    "deadline order", "task deadline", "slot profit", "time slot", "greedy strategy", "select jobs", "schedule greedy",
    "job task", "task schedule", "job selection", "profit based", "profit sort", "deadline sort", "job array",
    "job queue", "deadline based", "task array", "profit deadline", "greedy sort", "profit deadline max",
    "maximum job", "most profit", "sorted job", "deadline greedy", "job sort", "schedule task", "slot assignment",
    "best jobs", "highest profit", "task order profit", "greedy assignment", "maximize profit", "task optimize",
    "ordered jobs", "task greed", "profit first", "deadline first", "profit max", "profit jobs", "deadline max",
    "schedule profit", "max schedule", "highest job", "top profit", "greedy deadline", "sequence deadline", "task first",
    "job greedy algo", "deadline optimize", "time greedy", "schedule optimize", "priority task", "job priority deadline",
    "profit gain", "deadline range", "task order max", "greedy logic", "profit logic", "job pick", "profit pick",
    "deadline pick", "profit optimization", "scheduling algo", "job plan", "plan task", "max task", "max schedule",
    "profit-oriented", "sequence maximize", "greedy choice", "greedy path", "task maximize", "highest earning",
    "job plan profit", "best job select", "ordered profit", "deadline value", "time range job", "slot booking",
    "task planner", "time schedule", "deadline planner", "profit jobs pick", "best job algo", "job choice",
    "slot based", "range based", "task deadline sort", "greedy method", "maximum earnings", "task gain", "deadline job sort",
    "task sort deadline", "value task", "time planner", "job sort deadline", "job manager", "job schedule engine",
    "deadline match", "deadline job map", "profit match", "highest slot", "schedule engine", "slot match", "value jobs",
    "task list", "deadline list", "task deadline list", "slot chart", "profit planner", "schedule board", "task board",
    "maximized order", "ordered job", "task benefit", "job benefit", "task gain schedule", "job timeline",
    "deadline table", "max plan", "slot plan", "profit match sort", "ordered schedule", "profit decision",
    "task rank", "profit rank", "job position", "schedule task chart", "maximum result", "job maximize", "profit select",
    "choose jobs", "profit time", "deadline range task", "task select", "task choice", "job deadline profit",
    "task job pair", "profit over time", "slot deadline", "job optimize", "task optimize greedy", "task slot match",
    "slot select", "job priority sort", "task sort max", "slot profit sort", "job task engine", "greedy planner",
    "task deadline table", "timeline job", "profit from jobs", "max result", "profit maximize algorithm", "job chart",
    "profit-based select", "schedule fit", "greedy job chart", "greedy decision", "job pair", "job slot deadline",
    "greedy time", "slot-wise task", "maximum greedy", "maximize earnings", "slot assign", "assign job",
    "assign task slot", "sequence gain", "task planner map", "greedy job decision", "sequence jobs for gain",
    "best slot assign", "slot-wise planning", "maximum order", "profit management", "deadline optimize sort",
    "best match", "task match", "schedule job slot", "deadline fitting", "fitting job", "task by value",
    "slot wise planner", "best job match", "select best job", "maximize fit", "task deadline order", "profit gain planner",
    "task deadline rank", "slot rank", "task match engine", "profit-based greedy", "deadline filter", "job list filter",
    "job maximize logic", "profit based decision", "job value planner", "slot deadline planner", "task assign planner",
    "job benefit match", "time order", "profit table", "task gain logic", "priority-based task", "rank based task",
    "job table planner", "job filter planner", "profit calculator", "best slot picker", "slot filter", "deadline task planner",
    "greedy logic job", "job logic greedy", "task max value", "job max rank", "job gain sort", "max time profit",
    "job gain match", "task best plan", "task assign logic", "max time slot", "slot wise gain", "maximum planner",
    "job gain logic", "slot sequence", "time value task", "deadline vs profit", "time planner task", "profit gain match",
    "greedy table", "profit logic planner", "task filter", "job value sort", "gain match", "value-based planner",
    "profit order", "deadline order planner", "task sequence logic", "job sort gain", "job earnings", "earnings planner",
    "sequence planner", "job deadline planner", "job deadline map", "planner engine", "planner logic", "value logic",
    "match planner", "planner value", "slot deadline planner", "job selection engine", "task scheduling engine",
    "greedy time logic", "deadline slot logic", "profit planner sort", "job assign logic", "job chart deadline",
    "greedy schedule", "task deadline path", "profit gain planner", "job range", "task deadline path", "planner deadline",
    "slot finder", "slot assignment engine", "task optimizer", "job optimizer", "earnings table", "profit selector",
    "task value filter", "job list planner", "scheduler table", "priority slot", "job priority logic", "task manager logic",
    "sequence deadline profit", "slot logic", "task array planner", "task range planner", "job selection logic",
    "profit per task", "task earnings", "job list manager", "profit ranker", "deadline assigner", "task scheduler",
    "task allocator", "job allocator", "best job picker", "maximum job list", "value assigner", "value scheduler",
    "greedy decision engine", "job timeline planner", "slot maximize", "profit planner logic", "earnings manager",
    "task gain matcher", "maximum earnings logic", "deadline ranking", "time slot ranker", "task value finder",
    "job time allocator", "deadline scheduler", "value planner", "slot allocator", "time-based scheduling"
  ],
  nqueens: [
  "n queens", "n-queens", "queen placement", "chess queens", "backtracking queens", "n queen problem", "place queens",
  "no attack", "queen conflict", "safe queen", "board placement", "chess board", "n board", "chess problem",
  "non-attacking", "backtracking", "recursive queen", "place on board", "queen row", "queen column", "queen diagonal",
  "row safe", "col safe", "diag safe", "safe placement", "valid position", "valid queen", "queen solution",
  "backtracking chess", "queen algo", "n x n board", "safe cell", "non-threatening", "place recursively", "safe row",
  "safe col", "safe diag", "diagonal check", "horizontal check", "vertical check", "recursive placement", "recursive call",
  "check position", "backtrack queen", "solve board", "nqueen solver", "nqueen backtrack", "place safe",
  "row placement", "col placement", "no overlap", "queen threat", "queen attack", "conflict check", "chess rule",
  "n queen logic", "place n queens", "safe check", "queen condition", "queen verification", "placement verify",
  "recursive safe", "board fill", "n x n safe", "recursive board", "queen block", "queen valid", "backtrack step",
  "return back", "chess board algo", "board recursion", "recursive call check", "safe call", "queen puzzle",
  "board puzzle", "queen challenge", "place puzzle", "board safe", "safe queen algo", "queen attack check",
  "solve queen", "nqueen challenge", "placement algo", "safe checker", "nqueen config", "valid board", "nqueen grid",
  "solve n queens", "nqueen pattern", "pattern safe", "pattern backtrack", "row by row", "queen test", "valid solution",
  "generate config", "queen grid", "safe board", "place each row", "recursive queen place", "config check",
  "check for queen", "queen place grid", "board algorithm", "recursive grid", "queen rules", "nqueen rule set",
  "place without attack", "diagonal clash", "row clash", "col clash", "queen clash", "queen row check", "queen col check",
  "queen diag check", "n board queens", "queen logic", "chess queen config", "find placement", "generate solution",
  "solution list", "multiple solutions", "one solution", "print board", "board output", "print config", "queen success",
  "place successful", "recursive solution", "queen attempt", "queen placement logic", "non-attacking logic",
  "conflict avoid", "board recursion call", "place & check", "queen no threat", "recursive depth", "step by step board",
  "board queen step", "recursive structure", "queen search", "queen placement check", "recursive stack", "backtracking logic",
  "queen removal", "remove queen", "backtrack remove", "undo move", "board undo", "remove on fail", "fail and return",
  "board loop", "loop row", "loop column", "try placement", "try and check", "trial queen", "trial check", "n queen solution",
  "n queens full", "queen attempt logic", "recursive trial", "queen recursive checker", "row by row place", "chess attack",
  "queen grid check", "place smart", "chess board recursive", "recursive diagram", "queen conflict checker",
  "column attacker", "diagonal attacker", "row attacker", "attacker checker", "queen check matrix", "matrix solution",
  "n size board", "n board solution", "size n queens", "recursive success", "queen answer", "success board", "success config",
  "board result", "answer config", "place and backtrack", "try and backtrack", "queen check algo", "queen on grid",
  "grid queen", "grid safe", "grid check", "conflict matrix", "conflict grid", "safe queen grid", "matrix solution queen",
  "non-conflicting", "non-conflicting queens", "recursive position", "matrix queen", "recursion board", "n queens count",
  "total solutions", "all combinations", "queen permutation", "queen combination", "generate queens", "board generation",
  "solver function", "queen index", "grid recursive", "matrix fill", "queen no clash", "n board fill", "board state",
  "current state", "next row place", "recursive go", "recursive move", "move and check", "queen fill", "safe cell matrix",
  "track queen", "track safe", "path tracking", "check queen path", "no attack logic", "grid attack check", "chess safe",
  "row col diag", "3-way check", "triple check", "queen guards", "place guards", "check guards", "attack rules", 
  "valid config", "queen search path", "queen config logic", "generate all solutions", "check threats", "config builder",
  "safe config", "pattern generator", "board constructor", "row traversal", "col traversal", "grid traversal",
  "nboard checker", "cell safety", "queen filler", "recursion filler", "backtrack filler", "queen map", "map check",
  "map safe", "nmap board", "grid validator", "queen matrix search", "safe validator", "recursive queen grid",
  "safe diagonal", "diagonal validator", "main diag", "anti diag", "slash diag", "backslash diag", "check main diag",
  "check slash", "check backslash", "slash attack", "backslash attack", "attack map", "queen detect", "detect attack",
  "chess threat", "board checker", "recursive logic grid", "matrix placement", "non-repeating queen", "no repeat attack",
  "checker path", "step check", "step valid", "step back", "undo queen", "safe queen checker", "queen placement validator",
  "board queen build", "build solution", "queen layout", "board layout", "check layout", "pattern layout", "solution layout",
  "full safe", "n x n layout", "generate pattern", "check each cell", "valid cell", "chess matrix", "grid validator logic",
  "queen row fill", "col checker", "n chess problem", "recursive queen puzzle", "checker pattern", "queen checker pattern",
  "safe place loop", "loop safe", "nested recursion", "recursive map", "matrix loop", "safe queen grid logic",
  "queen mapping", "queen pattern logic", "stepwise checker", "queen placer", "board pattern", "place pattern",
  "pattern safe logic", "safe check pattern", "chess layout", "matrix layout", "n dimension board", "board fill logic",
  "queens across board", "board size n", "queen config result", "safe n grid", "n cell placement", "non-conflict check",
  "non-attacking check", "path check", "safe checker map", "map based queen", "row map", "column map", "diag map",
  "map tracker", "state tracker", "queen fill check", "matrix recursive path", "recursive grid check", "queen threat logic",
  "checker grid", "cell-by-cell placement", "recursive safe placement", "queens placed", "recursion queen loop", "final config"
],
  knapsack: [
  "knapsack problem", "0 1 knapsack", "01 knapsack", "fractional knapsack", "unbounded knapsack", "dynamic knapsack",
  "knapsack dp", "bag capacity", "item value", "item weight", "value weight", "capacity", "max value", "optimize weight",
  "select items", "pick items", "choose items", "maximize value", "minimize weight", "bag limit", "dp knapsack",
  "knapsack algo", "weight limit", "value optimize", "bounded knapsack", "knapsack optimization", "greedy knapsack",
  "knapsack greedy", "knapsack recursion", "recursive knapsack", "memoized knapsack", "knapsack top down",
  "knapsack bottom up", "knapsack dp table", "dp table", "dp array", "weight array", "value array", "knapsack total",
  "fill bag", "fill knapsack", "best value", "maximum value", "profit max", "min weight", "item selection",
  "decision making", "take or leave", "include item", "exclude item", "capacity check", "knapsack recursive call",
  "knapsack choice", "item index", "index value", "remaining capacity", "remaining weight", "item profit", "profit array",
  "knapsack value", "total weight", "total profit", "profit optimize", "capacity array", "item loop", "item list",
  "knapsack selection", "knapsack result", "optimize knapsack", "weight profit", "value pick", "pick or not",
  "knapsack choice table", "best combination", "choose best", "choose wisely", "selection logic", "loop items",
  "weight bound", "weight constraint", "capacity constraint", "profit table", "dp solution", "recurrence knapsack",
  "recursive solution", "dp recurrence", "optimal knapsack", "dynamic programming", "optimal solution", "recursive path",
  "backtrack knapsack", "decision matrix", "knapsack pattern", "knapsack formula", "v/w ratio", "value to weight",
  "ratio sort", "sorted items", "fractional logic", "fractional sort", "greedy choice", "profit ratio", "ratio greedy",
  "item selection ratio", "best ratio", "heap knapsack", "priority items", "priority queue", "capacity use", "full knapsack",
  "partial knapsack", "fill fraction", "partial item", "fractional take", "take portion", "take fraction", "total value",
  "maximum profit", "knapsack fill", "fill full", "fill part", "greedy fill", "greedy selection", "sort by ratio",
  "ratio based", "ratio sort logic", "value density", "density sort", "density greedy", "density choice", "weight reducer",
  "profit maximizer", "maximize knapsack", "maximize selection", "maximize fill", "fill capacity", "value maximization",
  "bounded capacity", "bag size", "choose from items", "fit in bag", "bag optimization", "weight usage", "space optimization",
  "recursive knapsack call", "recursive case", "include exclude", "base case", "termination condition", "if else case",
  "dp fill", "dp initialization", "initialize dp", "memoization table", "memo fill", "top down dp", "bottom up dp",
  "capacity iteration", "dp transition", "transition formula", "dp logic", "dp optimization", "tabulation knapsack",
  "tabulated solution", "dp grid", "knapsack grid", "dp approach", "space optimized", "1D dp", "2D dp", "space saver",
  "reduced space", "optimize space", "dp improvement", "value picker", "choose max value", "bag constraints",
  "optimization bag", "dp update", "update value", "dp matrix", "matrix update", "matrix fill", "dp bottom up fill",
  "recursion tree", "overlapping subproblems", "optimal substructure", "dp property", "recursive subproblem", "subproblem solving",
  "subproblem logic", "recurrence relation", "state transition", "knapsack states", "dp states", "state matrix",
  "subproblem matrix", "problem space", "recursive space", "memoized space", "recursive tree", "recursive weight",
  "value comparison", "max value choice", "knapsack base", "memoize subproblem", "tabulate knapsack", "dp loop",
  "item iterate", "item loop fill", "dp state update", "best fill", "best item pick", "best value fill", "knapsack max",
  "optimal fill", "fill logic", "selection logic", "knapsack iteration", "dp iteration", "fill array", "update dp",
  "item count", "item include", "item exclusion", "knapsack structure", "value table", "weight table", "total selection",
  "max combination", "combination value", "knapsack sum", "profit sum", "knapsack maximize", "fill value", "dp base case",
  "recursive base", "recursive value", "recursive call logic", "knapsack return", "return value", "dp function",
  "dp recursive", "fill dp", "tabulate array", "knapsack print", "print value", "print fill", "show selected", "chosen items",
  "knapsack output", "final knapsack", "final value", "final weight", "filled items", "filled capacity", "remaining capacity logic",
  "remaining space", "use capacity", "maximize using", "knapsack full", "partial fill", "selection strategy",
  "strategy selection", "smart selection", "selection problem", "bounded selection", "capacity balance", "balance weight",
  "fill balance", "pick wisely", "value vs weight", "weight vs value", "choose higher value", "choose lower weight",
  "fill with ratio", "greedy ratio", "knapsack fast", "efficient knapsack", "fast selection", "fast picker", "fill greedy",
  "bounded items", "limited items", "single pick", "one item once", "select once", "item use once", "unbounded choice",
  "multiple selection", "repeatable items", "unbounded loop", "unbounded fill", "repeat item", "multi pick", "item reuse",
  "reuse logic", "duplicate use", "multiple item pick", "dp optimization loop", "recursive pick", "recursive step",
  "step fill", "step decision", "recursive weight call", "capacity recursion", "capacity decrease", "decrease weight",
  "include logic", "exclude logic", "max of two", "recursive compare", "compare value", "value decision", "capacity limit logic",
  "limit cross", "weight sum", "knapsack walkthrough", "0/1 bag", "item fill strategy", "best use", "maximize bag", 
  "knapsack strategy", "0 1 decision", "greedy dp", "dp approach knapsack", "recursion + dp", "time complexity knapsack",
  "space complexity knapsack", "knapsack brute force", "dp efficiency", "knapsack variants", "standard knapsack",
  "classic knapsack", "advanced knapsack", "knapsack greedy approach", "weight sorted", "value sorted", "ratio picker",
  "sort items", "choose from sorted", "fill ratio", "fractional method", "greedy fill logic", "decimal fill", 
  "partial value", "partial fill method", "item cut", "take part", "take full", "take full or part", "part fill strategy",
  "best ratio picker", "item density", "value/weight", "dense item", "dense picker", "dense logic", "greedy capacity fill",
  "greedy based", "greedy logic fill", "profit fill", "bag filling", "value optimization", "maximum efficiency",
  "capacity usage", "item capacity fit", "capacity fit", "full use", "resource allocation", "budget optimization",
  "maximum value return"
],
  kruskal: [
  "kruskal algorithm", "minimum spanning tree", "mst", "graph edges", "edge list", "sort edges",
  "union find", "disjoint set", "cycle detection", "find parent", "union sets", "edge weight",
  "minimum cost", "graph vertices", "connected components", "greedy algorithm", "edge selection",
  "edge sorting", "sort by weight", "forest initialization", "mst edges", "graph connectivity",
  "disjoint set union", "union by rank", "path compression", "mst cost", "minimum edges",
  "graph cycle", "add edge", "edge check", "union operation", "find operation", "kruskal step",
  "mst building", "edge candidate", "sort edges weight", "graph representation", "undirected graph",
  "weighted graph", "edge pruning", "edge inclusion", "no cycle", "mst final", "mst result",
  "kruskal tree", "mst weight", "edge list sort", "mst algorithm steps", "kruskal pseudo code",
  "kruskal complexity", "time complexity", "O(E log E)", "edge sorting cost", "union find cost",
  "union find efficiency", "kruskal explanation", "spanning tree property", "graph edges list",
  "greedy selection", "minimum spanning", "minimum cost tree", "edge weight sorting", "disjoint sets",
  "kruskal data structures", "union find methods", "cycle prevention", "graph edges process",
  "mst edges select", "mst cost calc", "kruskal union", "kruskal find", "union find tree",
  "rank heuristic", "path compression optimization", "mst edge selection", "undirected weighted",
  "graph edges set", "kruskal initialization", "kruskal iterate edges", "mst edge adding",
  "kruskal union find", "kruskal disjoint set", "union find algorithms", "minimum cost spanning",
  "mst greedy approach", "connected graph", "graph edges union", "cycle detection method",
  "graph edges union find", "kruskal union heuristic", "mst building process", "kruskal edge check",
  "kruskal spanning tree", "kruskal best edges", "minimum edges tree", "graph mst problem",
  "minimum spanning solution", "kruskal steps", "graph mst algorithm", "kruskal union find ops",
  "kruskal weight calculation", "graph vertices union", "mst edge weight", "kruskal runtime",
  "edge sort optimization", "kruskal data structure usage", "graph connectivity check",
  "union find sets", "kruskal weighted graph", "mst construction", "edge sorting method",
  "kruskal performance", "disjoint set data structure", "kruskal graph processing",
  "cycle detection union", "kruskal greedy method", "mst edge inclusion", "kruskal graph traversal",
  "kruskal union find path compression", "minimum spanning tree problem", "graph weight sum",
  "mst edge set", "kruskal solution", "graph mst example", "kruskal application", "graph theory",
  "mst problem solving", "kruskal algorithm use", "graph edges sorting", "union find sets merge",
  "kruskal path compression", "kruskal rank heuristic", "kruskal union by rank", "graph edge weight",
  "kruskal initial sets", "mst graph edges", "kruskal disjoint set union", "mst greedy selection",
  "graph union find", "kruskal iterative process", "minimum cost edges", "kruskal edge list sort",
  "kruskal union find complexity", "kruskal spanning tree cost", "graph edges pruning",
  "kruskal tree construction", "mst final edges", "kruskal algorithm example",
  "kruskal tree edges", "union find methods efficiency", "graph union operations", "kruskal solution steps",
  "mst edge choosing", "kruskal algorithm explanation", "mst edge inclusion check",
  "kruskal step by step", "kruskal edge weight sorting", "minimum spanning tree edges",
  "kruskal initialization process", "graph edge cycles", "kruskal union find path",
  "mst building technique", "kruskal edges sorted", "kruskal sets union", "mst weight calculation",
  "kruskal graph edges sorted", "kruskal greedy approach", "mst minimum weight",
  "kruskal tree final", "kruskal graph edges union", "mst cost calculation", "kruskal union find example",
  "graph edges selection", "kruskal union find data structure", "kruskal pseudo code steps",
  "kruskal cycle detection union find", "mst edges selection", "graph edges union find cycle",
  "kruskal union find heuristic", "minimum spanning tree edges", "kruskal union find optimization",
  "kruskal greedy edge picking", "mst edges adding", "kruskal edges union find",
  "graph edges union find structure", "kruskal union find implementation", "mst problem explanation",
  "kruskal edge processing", "minimum cost graph", "kruskal spanning tree construction",
  "graph union find algorithm", "mst union find", "kruskal find and union", "kruskal union by rank heuristic",
  "kruskal path compression heuristic", "mst union find example", "graph edges weight sort",
  "kruskal iterative algorithm", "mst graph edge selection", "kruskal union find data structure example",
  "mst optimal solution", "kruskal spanning tree example", "graph edges weight sorting",
  "kruskal union find sets merge", "kruskal union find time complexity",
  "minimum spanning tree graph", "kruskal efficient algorithm", "mst graph edges union find",
  "kruskal union find union", "kruskal union find find", "graph edges sort by weight",
  "kruskal cycle detection method", "kruskal union find path compression heuristic",
  "mst greedy algorithm", "kruskal greedy edge picking heuristic", "kruskal implementation details",
  "mst weight sum calculation", "graph edges union find cycle detection", "kruskal minimum cost graph",
  "kruskal union find usage", "mst problem solution", "kruskal spanning tree greedy",
  "graph edges union find method", "kruskal union find data structure optimization",
  "kruskal union find complexity analysis", "mst construction greedy", "kruskal algorithm performance",
  "mst weight sum", "kruskal edge selection sorting", "kruskal union find usage example",
  "kruskal union find algorithm implementation", "mst final cost", "kruskal edges union find example",
  "graph edges union find union operation", "kruskal union find cycle check", "kruskal greedy algorithm approach",
  "mst minimum spanning tree edges", "kruskal union find path compression optimization", "kruskal algorithm overview",
  "mst graph edges union", "kruskal union find data structure efficiency", "kruskal union find cycle detection method",
  "kruskal minimum cost spanning tree", "graph edges union find data structure", "kruskal edge sorting complexity",
  "mst union find algorithm", "kruskal union find path compression heuristic implementation"
],
  prims: [
  "prim algorithm", "minimum spanning tree", "mst", "graph vertices", "adjacency matrix",
  "adjacency list", "priority queue", "min heap", "key array", "parent array",
  "mst set", "minimum edge", "extract min", "edge weight", "graph edges",
  "visited vertices", "mst cost", "greedy algorithm", "mst building", "graph connectivity",
  "graph representation", "graph initialization", "mst update", "key update",
  "priority update", "mst result", "mst final", "graph traversal", "vertex selection",
  "min key vertex", "visited array", "mst steps", "prim pseudocode",
  "time complexity", "O(E log V)", "graph vertices set", "graph weight",
  "mst edge inclusion", "graph update", "mst edge pick", "greedy edge pick",
  "mst path", "minimum edge weight", "vertex weight", "mst update key",
  "mst priority queue", "priority queue insert", "priority queue extract",
  "min weight vertex", "graph edge update", "mst iterative", "mst final cost",
  "graph weighted", "graph undirected", "graph edges list", "priority queue update",
  "mst parent", "mst initialization", "graph adjacency", "mst vertex add",
  "priority queue decrease key", "mst algorithm steps", "prim union find",
  "mst data structures", "graph edge weight", "mst greedy", "mst optimal",
  "graph edges update", "mst iteration", "mst edge select", "vertex key array",
  "mst edge set", "mst algorithm explanation", "prim stepwise", "mst build process",
  "graph edge weight update", "mst parent update", "prim heap", "priority queue implementation",
  "mst problem", "graph traversal order", "mst construction", "graph nodes",
  "mst iteration process", "mst algorithm example", "graph weight sum", "prim graph example",
  "priority queue efficiency", "mst selection criteria", "graph connectivity check", "mst final edges",
  "prim pseudocode steps", "mst solution", "graph edges weight", "mst weight calculation",
  "graph vertices key", "mst algorithm performance", "priority queue data structure", "graph edges process",
  "mst graph traversal", "prim greedy approach", "mst incremental build", "graph nodes update",
  "priority queue operations", "mst priority update", "graph edges list update", "mst iterative update",
  "prim graph traversal", "mst key update", "graph vertices set update", "mst edge picking",
  "graph vertex add", "mst greedy picking", "priority queue extract min", "mst parent array update",
  "graph weighted edges", "mst adjacency list", "graph adjacency matrix", "prim algorithm time complexity",
  "mst priority queue decrease", "mst incremental edge add", "graph edge weight array", "mst problem explanation",
  "mst weight sum", "prim priority queue operations", "graph edges selection", "mst greedy vertex pick",
  "prim algorithm implementation", "mst optimal solution", "priority queue min extraction", "graph update edges",
  "mst greedy vertex selection", "prim heap implementation", "graph edges weight update", "mst parent node",
  "priority queue update key", "mst graph representation", "prim algorithm steps", "mst greedy edge picking",
  "mst key decrease", "graph edges priority", "prim greedy algorithm explanation", "mst final weight",
  "priority queue efficiency optimization", "mst algorithm example steps", "mst optimal path", "mst graph update",
  "prim graph traversal order", "mst data structure usage", "graph edges priority queue", "mst iterative selection",
  "mst key array update", "prim priority queue min", "mst minimum edge selection", "mst incremental vertex add",
  "graph vertex update", "prim priority queue data structure", "mst greedy edge selection", "mst edge addition",
  "prim algorithm pseudocode", "graph vertices weight", "mst final result", "mst graph edges update",
  "priority queue operations efficiency", "mst minimum spanning tree", "prim graph vertices", "mst graph weight",
  "graph priority queue operations", "prim greedy approach explanation", "mst greedy key update", "mst parent pointer",
  "prim algorithm usage", "mst graph edge selection", "priority queue decrease key operation", "mst iterative update process",
  "prim algorithm complexity", "mst weighted graph", "priority queue implementation details", "mst edge picking steps",
  "mst parent array usage", "prim graph traversal pseudocode", "mst priority queue usage", "graph edges priority update",
  "mst greedy selection process", "prim minimum edge weight", "mst graph data structures", "mst key update process",
  "prim priority queue update key", "mst incremental edge pick", "graph vertices update process", "mst greedy vertex pick",
  "prim final result", "mst graph edge inclusion", "mst priority queue min extraction", "mst greedy algorithm steps",
  "mst graph representation update", "prim algorithm explanation", "mst incremental graph update", "mst key array initialization",
  "graph edges update process", "prim priority queue decrease", "mst greedy incremental build", "mst parent pointer update",
  "mst graph vertices update", "priority queue min key extraction", "prim algorithm iteration", "mst weighted edges",
  "mst greedy edge update", "prim algorithm performance", "mst iterative key update", "mst priority queue min key",
  "mst graph edges incremental update", "prim data structures", "mst graph traversal process", "mst greedy algorithm example"
]
};
